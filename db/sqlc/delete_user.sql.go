// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: delete_user.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUserDeleteRequest = `-- name: CreateUserDeleteRequest :exec
INSERT INTO account_recovery_requests (
    user_id, email, recovery_token, expires_at, completed_at
    )
VALUES ($1, $2, $3, $4, $5)
`

type CreateUserDeleteRequestParams struct {
	UserID        uuid.UUID          `json:"user_id"`
	Email         string             `json:"email"`
	RecoveryToken string             `json:"recovery_token"`
	ExpiresAt     time.Time          `json:"expires_at"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) CreateUserDeleteRequest(ctx context.Context, arg CreateUserDeleteRequestParams) error {
	_, err := q.db.Exec(ctx, createUserDeleteRequest,
		arg.UserID,
		arg.Email,
		arg.RecoveryToken,
		arg.ExpiresAt,
		arg.CompletedAt,
	)
	return err
}

const getUserFromDeleteReqByToken = `-- name: GetUserFromDeleteReqByToken :one
SELECT id, user_id, email, used, recovery_token, requested_at, expires_at, completed_at FROM account_recovery_requests WHERE recovery_token = $1 LIMIT 1
`

func (q *Queries) GetUserFromDeleteReqByToken(ctx context.Context, recoveryToken string) (AccountRecoveryRequest, error) {
	row := q.db.QueryRow(ctx, getUserFromDeleteReqByToken, recoveryToken)
	var i AccountRecoveryRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.Used,
		&i.RecoveryToken,
		&i.RequestedAt,
		&i.ExpiresAt,
		&i.CompletedAt,
	)
	return i, err
}

const markDeleteAsUsedByToken = `-- name: MarkDeleteAsUsedByToken :exec
UPDATE account_recovery_requests SET used = true, completed_at = now() WHERE recovery_token = $1
`

func (q *Queries) MarkDeleteAsUsedByToken(ctx context.Context, recoveryToken string) error {
	_, err := q.db.Exec(ctx, markDeleteAsUsedByToken, recoveryToken)
	return err
}
